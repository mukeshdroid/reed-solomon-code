

# This file was *autogenerated* from the file rscode.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_16 = Integer(16)#extended euclids algorithm
def extended_euclides(a,b,quo=lambda a,b:a//b):
    r0 = a; r1 = b
    s0 = _sage_const_1 ; s1 = _sage_const_0 
    t0 = _sage_const_0 ; t1 = _sage_const_1 

    while r1 != _sage_const_0 :
        q = quo(r0, r1)
        r0, r1 = r1, r0 - q * r1
        s0, s1 = s1, s0 - q * s1
        t0, t1 = t1, t0 - q * t1

    return r0, s0, t0

def toBinary(a):
    '''Converts a string to a string of binary values'''
    tmp = [str(int(bin(ord(i))[_sage_const_2 :])) for i in a]
    b = ""
    for i in tmp:
        b = b + i
    return b

def tobincoeffs(a,n):
    '''break the binary string passed into blocks of n length padding with zero'''
    #compute the number of blocks
    nb = int(len(a) / n) + _sage_const_1 
    
    #padding length needed
    np= nb * n - len(a) 
    
    a = a + np * '0'
    
    li = [a[i:i+n] for i in range(_sage_const_0 ,len(a),n)]
    
    return li


def msgtorscoeff(msg):
    '''change a messge to order of coefficients that will form the RS polynomials'''
    binary = toBinary(msg)
    coeffs = tobincoeffs(binary,_sage_const_4 )
    orders = [int(bString, _sage_const_2 ) for bString in coeffs]
    return orders

def rscoefftomsg(coeff):
    '''Converts a list of coefficents to ascii. reverse of msgtorscoeff'''
    coeff = reversed(coeff)
    F = GF(_sage_const_2 )['b']; (b,) = F._first_ngens(1)
    S = GF( _sage_const_2 **_sage_const_4 , modulus = b**_sage_const_4  + b**_sage_const_3  + _sage_const_1 , names=('a',)); (a,) = S._first_ngens(1)
    li = list(S)
    binstr = ''
    for i in coeff:
        indexi = li.index(i)
#         print(indexi)
        stri = '{0:04b}'.format(indexi)
#         print(stri)
        binstr = binstr + stri
#         print(binstr)
#     print(binstr)
    #remove padding
    nblocks = len(binstr) // _sage_const_7 
    binstr = binstr[:_sage_const_7  * nblocks]
    chrli = [binstr[i:i+_sage_const_7 ] for i in range(_sage_const_0 ,len(binstr),_sage_const_7 )]
#     print(chrli)
    chrs = [chr(int(i,_sage_const_2 )) for i in chrli]
    return chrs
    

class rs:
    
    def __init__(self):
        '''initialize a rs code with msg length 4'''
#         self.F.<b> = GF(2)[]
#         self.S.<a> = GF( 2**4, modulus = b^4 + b^3 + 1)
#         self.R.<x> = PolynomialRing(S,'x')
#         self.Syn.<z> = PolynomialRing(S,'z')
    
    def rs_encode(self,msg):
        F = GF(_sage_const_2 )['b']; (b,) = F._first_ngens(1)
        S = GF( _sage_const_2 **_sage_const_4 , modulus = b**_sage_const_4  + b**_sage_const_3  + _sage_const_1 , names=('a',)); (a,) = S._first_ngens(1)
        R = PolynomialRing(S,'x', names=('x',)); (x,) = R._first_ngens(1)
        Syn = PolynomialRing(S,'z', names=('z',)); (z,) = Syn._first_ngens(1)
        g = R([-a,_sage_const_1 ]) * R([-a**_sage_const_2 ,_sage_const_1 ]) * R([-a**_sage_const_3 ,_sage_const_1 ]) * R([-a**_sage_const_4 ,_sage_const_1 ]) * R([-a**_sage_const_5 ,_sage_const_1 ]) * R([-a**_sage_const_6 ,_sage_const_1 ])
        # convert the message to polynomial
        coeff = msgtorscoeff(msg)
        b = R(list(reversed([a**i for i in coeff])))
        print("message : {}".format(b))
        # generate the codeword
        c = g * b
        print("codeword: {}".format(c))
        return c

    def rs_decode(self,codeword):
        F = GF(_sage_const_2 )['b']; (b,) = F._first_ngens(1)
        S = GF( _sage_const_2 **_sage_const_4 , modulus = b**_sage_const_4  + b**_sage_const_3  + _sage_const_1 , names=('a',)); (a,) = S._first_ngens(1)
        R = PolynomialRing(S,'x', names=('x',)); (x,) = R._first_ngens(1)
        Syn = PolynomialRing(S,'z', names=('z',)); (z,) = Syn._first_ngens(1)
        g = R([-a,_sage_const_1 ]) * R([-a**_sage_const_2 ,_sage_const_1 ]) * R([-a**_sage_const_3 ,_sage_const_1 ]) * R([-a**_sage_const_4 ,_sage_const_1 ]) * R([-a**_sage_const_5 ,_sage_const_1 ]) * R([-a**_sage_const_6 ,_sage_const_1 ])
        r = R(codeword)
        print("r : {}".format(r))

        s1 = r(a)
        s2 = r(a**_sage_const_2 )
        s3 = r(a**_sage_const_3 )
        s4 = r(a**_sage_const_4 )
        s5 = r(a**_sage_const_5 )
        s6 = r(a**_sage_const_6 )
        
        #if all syndromes are zero there are no errors
        if (s1 == _sage_const_0 ) and (s2 == _sage_const_0 ) and (s3 == _sage_const_0 ) and (s4 == _sage_const_0 ) and (s5 == _sage_const_0 ) and (s6 == _sage_const_0 ):
            return ''.join(rscoefftomsg((r // g).coefficients(sparse=False)))
        print("{}|{}|{}|{}|{}|{}".format(s1,s2,s3,s4,s5,s6))
        Synpoly = s1 + s2 * z + s3 * z**_sage_const_2  + s4 * z**_sage_const_3  + s5 * z**_sage_const_4  + s6 * z**_sage_const_5 
        az = Syn([_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ])
        gcdz , uz, vz = extended_euclides(az,Synpoly)
        gcdz = gcdz
        uz = uz 
        vz = vz
        invroot_indices = []
        for i in range(_sage_const_1 ,_sage_const_16 ):
            if vz(a**i) == _sage_const_0 :
                invroot_indices.append(i)
        # these are the error positions
        root_indices = {}
        for i in invroot_indices:
            root_indices[i] = len(list(S)) -_sage_const_1  -i
        #get coefficients of the error position
        vzdif = vz.diff()
        error_coeff = {}
        for i in invroot_indices:
               error_coeff[root_indices[i]] = (gcdz(a**i) / vzdif(a**i))
        li = [_sage_const_0  for i in range(_sage_const_0 ,_sage_const_16 )]
        for i in error_coeff:
            li[i] = error_coeff[i]
        error_poly = R(list(li))
        print("error_poly : {}".format(error_poly))
        print("decoded_codeword : {}".format(r - error_poly))
        return ''.join(rscoefftomsg(((r - error_poly) // g).coefficients(sparse=False)))

